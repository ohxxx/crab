fn main() {
    // 因为变量要负责释放它们拥有的资源，所以资源只能有一个所有者
    // 这也防止了资源的重复释放，并不是所有变量都拥有资源（例如引用）

    // 在进行赋值（let a = b）或者通过值传递函数参数（foo(a)）的时候，资源的所有权会发生转移
    // 按照 rust 的规范，这被称为资源的移动（move），在移动资源后，原来的所有者不能再被使用，这可避免悬挂指针（dangling pointer）的产生

    // 内存分为两大类：栈 stack 和 堆 heap

    // 【栈】
    // 后进先出的机制。一个变量要放到站上，那么它的大小在编译时就要明确。i32 类型的变量，它就是占用4个字节。rust 中可以放到栈上的数据类型，它们的大小是固定的
    // 如果是字符串，在运行时才会赋值的变量，在编译期的时候大小是未知或不确定的，所以字符串类型存储在堆上

    // 【堆】
    // 在编译时大小未知或确定的，只有运行时才能确定的数据，在堆上存储一些动态类型的数据。堆是不受系统管理的，是用户自己管理，也增加了内存溢出的风险

    // 【所有权】
    // 所有权就是值一个东西归属谁，rust 中一个变量对应一个值，变量就称为这个值所有者
    // let xxx = "halo xxx" >>> "halo xxx"这个值所在内存块由变量 name 所有

    // 转让所有权
    // 栈分配的整型
    let a = 888;
    // 将 `a` 复制到 `b`，这里没有发生所有权转移
    let b = a;
    println!("a = {}, b = {}", a, b);

    // 堆分配的字符串
    let s1 = vec!["halo", "xxx"];
    let s2 = s1; // 这里发生了所有权转移，s1 不再有效，s2 现在拥有这个值;

    // println!("s1 = {:?}, s2 = {:?}", s1, s2);
    // s1 拥有堆上数据的所有权，当 s2 = s1 时，s1 的所有权转移到了 s2，s1 不再有效，s2 现在拥有这个值

    // 将变量传递给函数参数
    let s3 = vec!["halo", "xxx"];
    let s4 = s3;
    show(s4);
    // println!("s3 = {:?}, s4 = {:?}", s3, s4);

    // 函数中的返回值
    let s5 = vec!["halo", "xxx"];
    let s6 = s5;
    let res = show2(s6);
    println!("res = {:?}", res);

    // 基础数据类型的所有权
    // 所有权只会发生在堆上分配的数据，基础数据类型（整型、浮点型、布尔、字符）存储在栈上，所以没有所有权的概念。
    // 基础类型可以认为是值拷贝，在内存上另外的地方，存储和复制来的数据，然后让新的变量指向他
    // 赋值并不是唯一涉及所有权移动的操作，值作为参数传递或从函数返回时，也会发生所有权移动
}

fn show(s: Vec<&str>) {
    println!("s = {:?}", s);
}

fn show2(s: Vec<&str>) -> Vec<&str> {
    println!("s = {:?}", s);
    return s;
}
